---
title: "A friendly introduction to assembly for high-level programmers — Functions"
description: "A friendly introduction to assembly for high-level programmers — Functions"
categories: ["assembly", "x86", "guide"]
date: "2024-09-24"
series: A friendly introduction to assembly for high-level programmers
---

[In the previous article]({% post_url 2024-09-16-x86-64-conditionals %}) we learned about Control Transfer Instructions, and we have seen how they are the cornerstone of control flow in assembly. We looked at the simplest of them, jump, and learned how to implement conditionals.

Today we will look at reproducing functions. Starting with no arguments, `void` functions, all the way up to functions returning multiple values.

{% assign series_name = page.series %} {% include collection.html name=series_name %}

## Nullary Void Functions

The definition of function[^1] we will be using in this article is:

> A reusable portion of a program that can take inputs and return outputs

Let's start with the simplest case: a function that takes no arguments and returns no values.

From what we have seen in the previous article, jumps might seem like a good approximation of a function: they provide a mechanism to execute code from elsewhere, and they even have a human-readable name. What could one desire more?

In high-level languages, functions do their job and hand back control to the caller once they are done, typically with the `return` keyword. Jumps, on the other hand, are one-way control transfer: once you jump to a location there is no way back, unless the callee knows where to jump to.

The premise that we need to control callee and caller hinders reusability, the first property we expect from functions. For example, we would be unable to use third-party libraries in our programs since their implementations would need to know details about the calling code (specifically, where to jump back).

How do we make this execution model independent of the caller? 

At any point in time, we know the address of the instruction in execution: it's in the `rip`. The caller can store the `rip` before jumping, and expect the callee to jump back to the next instruction after the stored location. Victory!

The only problem we have left is that all this bookkeeping is tedious and error-prone. This is why assembly comes with two instructions, `call` (call) and `ret` (return) that do the math for us. Let's look at them.

The first, `call` looks very much like a jump
```nasm
call label
```
and, under the hood, is not that different: it jumps to the provided label, but before jumping, it stores the address of the current instruction in a special location of the memory called _the stack_. 

We will look into the details of the stack in the next article. For now, all you need to know is that it's a memory location where you can store values and retrieve them later.

Much like in high-level languages, at the end of a function we _return_ to hand the control back to the caller. In assembly, we do the same utilizing the `ret` (return) instruction
```nasm
label:
  ; code of the function
  ret
```
Just like a [Scooby Doo mask off moment](https://www.youtube.com/watch?v=L0ozIHomn8Q&t=174s), what we see is once again a jump: `ret` fetches the value stored on _the stack_ by `call` and jumps back there, giving back control without having to know anything about the caller. 

Let's look at a concrete example. 

We will create a program to roll a die, like in a tabletop game. We will make use of our shiny new tool, functions, and we will learn a couple more instructions along the way.

<code-editor exercise="03-nullary-functions.asm"></code-editor>

## Here Comes Arity

* how does one pass arguments to a function in assembly?
* in a nutshell, you put them in a register and read the register from within the function
* which register?
  * calling conventions: they are part of the ABI and specific to the operative system. Since this is about linux, we use AMD64 (which applies also to macos)
  * They say how one receives and returns parameters and specify whose responsibility is to preserve the registers value in the function lifecycle (requires stack, next time)
  * They are needed for interop and to interact with code you don't control

## Conclusion

{% include post-footer.html %}

---

[^1]: Turns out that finding an agreed upon definition of function is not easy. Imagine how different the idea of function is between functional programming, lambda calculus, and mathematics, for example. Speaking of wide definitions, here's a fun personal anecdote: during my studies I had two _harmonic functions_ classes in the same semester, one in math school and the other in jazz school.

{% include code-editor.html %}
