---
title: "A friendly introduction to assembly for high-level programmers — Functions & Loops"
description: "A friendly introduction to assembly for high-level programmers — Functions & Loops"
categories: ["assembly", "x86", "guide"]
date: "2024-09-24"
series: A friendly introduction to assembly for high-level programmers
---

[In the previous article]({% post_url 2024-09-16-x86-64-conditionals %}) we learned about Control Transfer Instructions, and we have seen how they are the cornerstone of control flow in assembly. We looked at the simplest of them, jump, and learned how to implement conditionals.

Today we will look at reproducing functions. Starting with no arguments, `void` functions, all the way up to functions returning multiple values.

{% assign series_name = page.series %} {% include collection.html name=series_name %}

## Nullary Void Functions

The definition of function[^1] we will be using in this article is:

> A reusable portion of a program that can take inputs and return outputs

Let's start with the simplest case: a function that takes no arguments and returns no values.

From what we have seen in the previous article, _jumps_ seem like a good approximation of a function: they provide a mechanism to execute code from elsewhere, and they have a human-readable name. What could one desire more?

In high-level languages, functions do their job and hand back control to the caller once they are done, typically with the `return` keyword. Jumps, on the other hand, are _one-way control transfer_: once you jump to a location there is no way back, unless the callee knows where to jump to.

The premise that we need to control callee and caller hinders _reusability_, the first property we expect from functions. Imagine trying to use third-party libraries in your program; their functions would have to know details about your code’s structure and where to jump back, making it impossible to write modular or reusable code.

How do we make this execution model _caller-independent_? 

At any point in time, we know the address of the instruction in execution: it's in the `rip`. The caller can store the `rip` before jumping, and expect the callee to jump back to the next instruction after the stored location. Victory!

The only problem we have left is that all this bookkeeping is tedious and error-prone. This is why assembly comes with two instructions, `call` (call) and `ret` (return) that do the math for us. Let's look at them.

The first, `call` looks very much like a jump
```nasm
call label
```
and, under the hood, is not that different: it jumps to the provided label, but before jumping, it stores the address of the current instruction in a special location of the memory called _the stack_. 

We will look into the details of the stack in the next article. For now, all you need to know is that it's a memory location where you can store values and retrieve them later.

Much like in high-level languages, at the end of a function we _return_ to hand the control back to the caller. In assembly, we do the same utilizing the `ret` (return) instruction
```nasm
label:
  ; code of the function
  ret
```
Just like a [Scooby Doo mask off moment](https://www.youtube.com/watch?v=L0ozIHomn8Q&t=174s), what we see is once again a jump: `ret` fetches the value stored on _the stack_ by `call` and jumps back there, giving back control without having to know anything about the caller. 

Let's look at a concrete example. 

We’re going to create a little [dungeon crawler](https://en.wikipedia.org/wiki/Dungeon_crawl) game where our explorer navigates a maze to find a treasure. We will learn a few new instructions and make extensive use of functions and their reusability to reduce boilerplate. Incidentally, we will find out that we have all we need to implement loops in assembly, our second high-level programming concept for this article.

<code-editor exercise="03-nullary-functions.asm"></code-editor>

## Here Comes Arity

Alright, that was a lot to take in! But the good news is we’ve already covered most of the heavy lifting for today. Great job!

Now, we only have two key concepts left: **passing parameters** and **returning values** in functions. And the best part? You've already seen both!

In the examples above, we got comfortable with passing data between functions using **registers**. 

For example, before calling `print`, we set the values of `rsi` and `rdx` so that the function had the right data in the correct registers. That's how parameters are typically[^2] passed to functions in assembly.

Returning values works the same, but in reverse: when a function needs to return a result, it places the value in a designated register, allowing the caller to retrieve it from there.

This system does feel a bit brittle, doesn’t it? How can we make sure that functions don’t overwrite registers we're relying on? How do we decide which registers to use inside a function? And how do we maintain values across function calls?

### Calling Conventions

Since there is no way to enforce any rules in this regard, assembly relies on _calling conventions_. Calling conventions are a scheme defining how functions receive parameters, how they return results, and who is responsible for preserving values in registers.

Calling conventions are part of the Application Binary Interface (ABI), a contract between the operating system and the binaries it runs. You can imagine the ABI like the low-level version of what an API (Application Programming Interface) does when two or more software communicate with each other.

Since the code we are concerned with is written for Linux, the ABI of reference will be [System V AMD64 ABI](https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build). Here's an excerpt of the most relevant information. (see Register Usage table)


Let's see another example to solidify this knowledge.

* which register?
  * They are needed for interop and to interact with code you don't control

## Conclusion

{% include post-footer.html %}

---

[^1]: Turns out that finding an agreed upon definition of function is not easy. Imagine how different the idea of function is between functional programming, lambda calculus, and mathematics, for example. Speaking of wide definitions, here's a fun personal anecdote: during my studies I had two _harmonic functions_ classes in the same semester, one in math school and the other in jazz school.

[^2]: You might be wondering what happens when you have more arguments than registers or when data is larger than a register's size. In the next lesson we will learn more about the stack and answer all these questions. 

{% include code-editor.html %}
