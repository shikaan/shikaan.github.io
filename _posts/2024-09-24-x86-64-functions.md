---
title: "A friendly introduction to assembly for high-level programmers — Functions"
description: "A friendly introduction to assembly for high-level programmers — Functions"
categories: ["assembly", "x86", "guide"]
date: "2024-09-24"
series: A friendly introduction to assembly for high-level programmers
---

[In the previous article]({% post_url 2024-09-16-x86-64-conditionals %}) we learned about Control Transfer Instructions and we have seen how they are the cornerstone of control flow in assembly. We looked at the simplest of them, jump, and learned how to implement conditionals.

Today we will look at reproducing functions. Starting from no arguments, `void` functions, all the way up to functions retuning multiple values.

{% assign series_name = page.series %} {% include collection.html name=series_name %}

## Nullary Void Functions

The definition of function we will be using throughout our discussion is as follows:

> A reusable portion of a program that can take inputs and return outputs

It's clearly not formal[^1], but it provides a general understanding that will serve our purposes in exploring the topic.

Let's start with the simplest case: a function that takes no arguments and returns no values.

For what we have seen in the previous article, jumps might seem a good approximation of a function: they provide a mechanism to execute code from a different place and they even have a human-readable name. What could one desire more?

For one, jumps are unidirectional control transfer. Typically, when a function is invoked, you want it to do its job and hand back control to the caller once they are done. 

// Reword
> The code that calls other code is called `caller` and the called code is called `callee`.

For example
```c
int main() {
  // do something
  int a = 1;

  // invoke function
  my_function();

  // continue doing something
  int b = a + 1;
}
```
Per se, jumps won't be able to give you that: once you jump to a location, the execution keeps moving sequentially, and the caller has lost control. 

If the caller wants to take back control, they need to rely on the callee to jump to a position within the body of the callee. More specifically, if you want to have the same behavior as above whereby, after the callee runs the execution continues at the line after the function, the caller needs store the `rip` (the instruction pointer) somewhere such that the callee can jump to `rip` + 1 once they are done. 


* jumps got us very close to modeling functions: we can jump to code living somewhere else and this block has a "name" we can point to
* jumps have shortcomings, since you need to keep jumping otherwise the execution proceeds and the caller loses control
* you can model functions with jumps, you just need to jump back to the line after the one where you do the invocation
* unfortunately this makes these routines not reusable, unless they always know where they have been called from
* all this book keeping is tedious and error prone, and that's why we have the call instruction and the return instruction
* call preforms a jump, but stores the staring in the stack (which we will explore in depth in the next lesson)
* return pops the starting position off of the stack and jumps there

## Here Comes Arity

* how does one pass arguments to a function in assembly?
* in a nutshell, you put them in a register and read the register from within the function
* which register?
  * calling conventions: they are part of the ABI and specific to the operative system. Since this is about linux, we use AMD64 (which applies also to macos)
  * They say how one receives and returns parameters and specify whose responsibility is to preserve the registers value in the function lifecycle (requires stack, next time)
  * They are needed for interop and to interact with code you don't control

## Examples

## Conclusion

{% include post-footer.html %}

---

[^1]: Finding a canned definition of function is no easy feat. Imagine how different the idea of function is between functional programming, lambda calculus, and mathematics for example. Fun personal anecdote: during my studies I had two "harmonic functions" classes at the same time, one in math school and the other in jazz school. 

{% include code-editor.html %}
